// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countOverdueTransactions = `-- name: CountOverdueTransactions :one
SELECT COUNT(*) FROM transactions
WHERE due_date < NOW() AND returned_date IS NULL
`

func (q *Queries) CountOverdueTransactions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOverdueTransactions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTransactions = `-- name: CountTransactions :one
SELECT COUNT(*) FROM transactions
`

func (q *Queries) CountTransactions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countTransactions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (student_id, book_id, transaction_type, due_date, librarian_id, notes)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, student_id, book_id, transaction_type, transaction_date, due_date, returned_date, librarian_id, fine_amount, fine_paid, notes, created_at, updated_at
`

type CreateTransactionParams struct {
	StudentID       int32            `db:"student_id" json:"student_id"`
	BookID          int32            `db:"book_id" json:"book_id"`
	TransactionType string           `db:"transaction_type" json:"transaction_type"`
	DueDate         pgtype.Timestamp `db:"due_date" json:"due_date"`
	LibrarianID     pgtype.Int4      `db:"librarian_id" json:"librarian_id"`
	Notes           pgtype.Text      `db:"notes" json:"notes"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.StudentID,
		arg.BookID,
		arg.TransactionType,
		arg.DueDate,
		arg.LibrarianID,
		arg.Notes,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.BookID,
		&i.TransactionType,
		&i.TransactionDate,
		&i.DueDate,
		&i.ReturnedDate,
		&i.LibrarianID,
		&i.FineAmount,
		&i.FinePaid,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT t.id, t.student_id, t.book_id, t.transaction_type, t.transaction_date, t.due_date, t.returned_date, t.librarian_id, t.fine_amount, t.fine_paid, t.notes, t.created_at, t.updated_at, s.first_name, s.last_name, s.student_id, b.title, b.author, b.book_id
FROM transactions t
JOIN students s ON t.student_id = s.id
JOIN books b ON t.book_id = b.id
WHERE t.id = $1
`

type GetTransactionByIDRow struct {
	ID              int32            `db:"id" json:"id"`
	StudentID       int32            `db:"student_id" json:"student_id"`
	BookID          int32            `db:"book_id" json:"book_id"`
	TransactionType string           `db:"transaction_type" json:"transaction_type"`
	TransactionDate pgtype.Timestamp `db:"transaction_date" json:"transaction_date"`
	DueDate         pgtype.Timestamp `db:"due_date" json:"due_date"`
	ReturnedDate    pgtype.Timestamp `db:"returned_date" json:"returned_date"`
	LibrarianID     pgtype.Int4      `db:"librarian_id" json:"librarian_id"`
	FineAmount      pgtype.Numeric   `db:"fine_amount" json:"fine_amount"`
	FinePaid        pgtype.Bool      `db:"fine_paid" json:"fine_paid"`
	Notes           pgtype.Text      `db:"notes" json:"notes"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	FirstName       string           `db:"first_name" json:"first_name"`
	LastName        string           `db:"last_name" json:"last_name"`
	StudentID_2     string           `db:"student_id_2" json:"student_id_2"`
	Title           string           `db:"title" json:"title"`
	Author          string           `db:"author" json:"author"`
	BookID_2        string           `db:"book_id_2" json:"book_id_2"`
}

func (q *Queries) GetTransactionByID(ctx context.Context, id int32) (GetTransactionByIDRow, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, id)
	var i GetTransactionByIDRow
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.BookID,
		&i.TransactionType,
		&i.TransactionDate,
		&i.DueDate,
		&i.ReturnedDate,
		&i.LibrarianID,
		&i.FineAmount,
		&i.FinePaid,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstName,
		&i.LastName,
		&i.StudentID_2,
		&i.Title,
		&i.Author,
		&i.BookID_2,
	)
	return i, err
}

const listActiveBorrowings = `-- name: ListActiveBorrowings :many
SELECT t.id, t.student_id, t.book_id, t.transaction_type, t.transaction_date, t.due_date, t.returned_date, t.librarian_id, t.fine_amount, t.fine_paid, t.notes, t.created_at, t.updated_at, s.first_name, s.last_name, s.student_id, b.title, b.author, b.book_id
FROM transactions t
JOIN students s ON t.student_id = s.id
JOIN books b ON t.book_id = b.id
WHERE t.returned_date IS NULL
ORDER BY t.due_date ASC
LIMIT $1 OFFSET $2
`

type ListActiveBorrowingsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListActiveBorrowingsRow struct {
	ID              int32            `db:"id" json:"id"`
	StudentID       int32            `db:"student_id" json:"student_id"`
	BookID          int32            `db:"book_id" json:"book_id"`
	TransactionType string           `db:"transaction_type" json:"transaction_type"`
	TransactionDate pgtype.Timestamp `db:"transaction_date" json:"transaction_date"`
	DueDate         pgtype.Timestamp `db:"due_date" json:"due_date"`
	ReturnedDate    pgtype.Timestamp `db:"returned_date" json:"returned_date"`
	LibrarianID     pgtype.Int4      `db:"librarian_id" json:"librarian_id"`
	FineAmount      pgtype.Numeric   `db:"fine_amount" json:"fine_amount"`
	FinePaid        pgtype.Bool      `db:"fine_paid" json:"fine_paid"`
	Notes           pgtype.Text      `db:"notes" json:"notes"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	FirstName       string           `db:"first_name" json:"first_name"`
	LastName        string           `db:"last_name" json:"last_name"`
	StudentID_2     string           `db:"student_id_2" json:"student_id_2"`
	Title           string           `db:"title" json:"title"`
	Author          string           `db:"author" json:"author"`
	BookID_2        string           `db:"book_id_2" json:"book_id_2"`
}

func (q *Queries) ListActiveBorrowings(ctx context.Context, arg ListActiveBorrowingsParams) ([]ListActiveBorrowingsRow, error) {
	rows, err := q.db.Query(ctx, listActiveBorrowings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveBorrowingsRow{}
	for rows.Next() {
		var i ListActiveBorrowingsRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.BookID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.DueDate,
			&i.ReturnedDate,
			&i.LibrarianID,
			&i.FineAmount,
			&i.FinePaid,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.StudentID_2,
			&i.Title,
			&i.Author,
			&i.BookID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveTransactionsByStudent = `-- name: ListActiveTransactionsByStudent :many
SELECT t.id, t.student_id, t.book_id, t.transaction_type, t.transaction_date, t.due_date, t.returned_date, t.librarian_id, t.fine_amount, t.fine_paid, t.notes, t.created_at, t.updated_at, b.title, b.author, b.book_id
FROM transactions t
JOIN books b ON t.book_id = b.id
WHERE t.student_id = $1 AND t.returned_date IS NULL
ORDER BY t.due_date ASC
`

type ListActiveTransactionsByStudentRow struct {
	ID              int32            `db:"id" json:"id"`
	StudentID       int32            `db:"student_id" json:"student_id"`
	BookID          int32            `db:"book_id" json:"book_id"`
	TransactionType string           `db:"transaction_type" json:"transaction_type"`
	TransactionDate pgtype.Timestamp `db:"transaction_date" json:"transaction_date"`
	DueDate         pgtype.Timestamp `db:"due_date" json:"due_date"`
	ReturnedDate    pgtype.Timestamp `db:"returned_date" json:"returned_date"`
	LibrarianID     pgtype.Int4      `db:"librarian_id" json:"librarian_id"`
	FineAmount      pgtype.Numeric   `db:"fine_amount" json:"fine_amount"`
	FinePaid        pgtype.Bool      `db:"fine_paid" json:"fine_paid"`
	Notes           pgtype.Text      `db:"notes" json:"notes"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Title           string           `db:"title" json:"title"`
	Author          string           `db:"author" json:"author"`
	BookID_2        string           `db:"book_id_2" json:"book_id_2"`
}

func (q *Queries) ListActiveTransactionsByStudent(ctx context.Context, studentID int32) ([]ListActiveTransactionsByStudentRow, error) {
	rows, err := q.db.Query(ctx, listActiveTransactionsByStudent, studentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveTransactionsByStudentRow{}
	for rows.Next() {
		var i ListActiveTransactionsByStudentRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.BookID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.DueDate,
			&i.ReturnedDate,
			&i.LibrarianID,
			&i.FineAmount,
			&i.FinePaid,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Author,
			&i.BookID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOverdueTransactions = `-- name: ListOverdueTransactions :many
SELECT t.id, t.student_id, t.book_id, t.transaction_type, t.transaction_date, t.due_date, t.returned_date, t.librarian_id, t.fine_amount, t.fine_paid, t.notes, t.created_at, t.updated_at, s.first_name, s.last_name, s.student_id, b.title, b.author, b.book_id
FROM transactions t
JOIN students s ON t.student_id = s.id
JOIN books b ON t.book_id = b.id
WHERE t.due_date < NOW() AND t.returned_date IS NULL
ORDER BY t.due_date ASC
`

type ListOverdueTransactionsRow struct {
	ID              int32            `db:"id" json:"id"`
	StudentID       int32            `db:"student_id" json:"student_id"`
	BookID          int32            `db:"book_id" json:"book_id"`
	TransactionType string           `db:"transaction_type" json:"transaction_type"`
	TransactionDate pgtype.Timestamp `db:"transaction_date" json:"transaction_date"`
	DueDate         pgtype.Timestamp `db:"due_date" json:"due_date"`
	ReturnedDate    pgtype.Timestamp `db:"returned_date" json:"returned_date"`
	LibrarianID     pgtype.Int4      `db:"librarian_id" json:"librarian_id"`
	FineAmount      pgtype.Numeric   `db:"fine_amount" json:"fine_amount"`
	FinePaid        pgtype.Bool      `db:"fine_paid" json:"fine_paid"`
	Notes           pgtype.Text      `db:"notes" json:"notes"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	FirstName       string           `db:"first_name" json:"first_name"`
	LastName        string           `db:"last_name" json:"last_name"`
	StudentID_2     string           `db:"student_id_2" json:"student_id_2"`
	Title           string           `db:"title" json:"title"`
	Author          string           `db:"author" json:"author"`
	BookID_2        string           `db:"book_id_2" json:"book_id_2"`
}

func (q *Queries) ListOverdueTransactions(ctx context.Context) ([]ListOverdueTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listOverdueTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOverdueTransactionsRow{}
	for rows.Next() {
		var i ListOverdueTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.BookID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.DueDate,
			&i.ReturnedDate,
			&i.LibrarianID,
			&i.FineAmount,
			&i.FinePaid,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.StudentID_2,
			&i.Title,
			&i.Author,
			&i.BookID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT t.id, t.student_id, t.book_id, t.transaction_type, t.transaction_date, t.due_date, t.returned_date, t.librarian_id, t.fine_amount, t.fine_paid, t.notes, t.created_at, t.updated_at, s.first_name, s.last_name, s.student_id, b.title, b.author, b.book_id
FROM transactions t
JOIN students s ON t.student_id = s.id
JOIN books b ON t.book_id = b.id
ORDER BY t.transaction_date DESC
LIMIT $1 OFFSET $2
`

type ListTransactionsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListTransactionsRow struct {
	ID              int32            `db:"id" json:"id"`
	StudentID       int32            `db:"student_id" json:"student_id"`
	BookID          int32            `db:"book_id" json:"book_id"`
	TransactionType string           `db:"transaction_type" json:"transaction_type"`
	TransactionDate pgtype.Timestamp `db:"transaction_date" json:"transaction_date"`
	DueDate         pgtype.Timestamp `db:"due_date" json:"due_date"`
	ReturnedDate    pgtype.Timestamp `db:"returned_date" json:"returned_date"`
	LibrarianID     pgtype.Int4      `db:"librarian_id" json:"librarian_id"`
	FineAmount      pgtype.Numeric   `db:"fine_amount" json:"fine_amount"`
	FinePaid        pgtype.Bool      `db:"fine_paid" json:"fine_paid"`
	Notes           pgtype.Text      `db:"notes" json:"notes"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	FirstName       string           `db:"first_name" json:"first_name"`
	LastName        string           `db:"last_name" json:"last_name"`
	StudentID_2     string           `db:"student_id_2" json:"student_id_2"`
	Title           string           `db:"title" json:"title"`
	Author          string           `db:"author" json:"author"`
	BookID_2        string           `db:"book_id_2" json:"book_id_2"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]ListTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTransactionsRow{}
	for rows.Next() {
		var i ListTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.BookID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.DueDate,
			&i.ReturnedDate,
			&i.LibrarianID,
			&i.FineAmount,
			&i.FinePaid,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.StudentID_2,
			&i.Title,
			&i.Author,
			&i.BookID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByBook = `-- name: ListTransactionsByBook :many
SELECT t.id, t.student_id, t.book_id, t.transaction_type, t.transaction_date, t.due_date, t.returned_date, t.librarian_id, t.fine_amount, t.fine_paid, t.notes, t.created_at, t.updated_at, s.first_name, s.last_name, s.student_id
FROM transactions t
JOIN students s ON t.student_id = s.id
WHERE t.book_id = $1
ORDER BY t.transaction_date DESC
LIMIT $2 OFFSET $3
`

type ListTransactionsByBookParams struct {
	BookID int32 `db:"book_id" json:"book_id"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListTransactionsByBookRow struct {
	ID              int32            `db:"id" json:"id"`
	StudentID       int32            `db:"student_id" json:"student_id"`
	BookID          int32            `db:"book_id" json:"book_id"`
	TransactionType string           `db:"transaction_type" json:"transaction_type"`
	TransactionDate pgtype.Timestamp `db:"transaction_date" json:"transaction_date"`
	DueDate         pgtype.Timestamp `db:"due_date" json:"due_date"`
	ReturnedDate    pgtype.Timestamp `db:"returned_date" json:"returned_date"`
	LibrarianID     pgtype.Int4      `db:"librarian_id" json:"librarian_id"`
	FineAmount      pgtype.Numeric   `db:"fine_amount" json:"fine_amount"`
	FinePaid        pgtype.Bool      `db:"fine_paid" json:"fine_paid"`
	Notes           pgtype.Text      `db:"notes" json:"notes"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	FirstName       string           `db:"first_name" json:"first_name"`
	LastName        string           `db:"last_name" json:"last_name"`
	StudentID_2     string           `db:"student_id_2" json:"student_id_2"`
}

func (q *Queries) ListTransactionsByBook(ctx context.Context, arg ListTransactionsByBookParams) ([]ListTransactionsByBookRow, error) {
	rows, err := q.db.Query(ctx, listTransactionsByBook, arg.BookID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTransactionsByBookRow{}
	for rows.Next() {
		var i ListTransactionsByBookRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.BookID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.DueDate,
			&i.ReturnedDate,
			&i.LibrarianID,
			&i.FineAmount,
			&i.FinePaid,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.StudentID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByStudent = `-- name: ListTransactionsByStudent :many
SELECT t.id, t.student_id, t.book_id, t.transaction_type, t.transaction_date, t.due_date, t.returned_date, t.librarian_id, t.fine_amount, t.fine_paid, t.notes, t.created_at, t.updated_at, b.title, b.author, b.book_id
FROM transactions t
JOIN books b ON t.book_id = b.id
WHERE t.student_id = $1
ORDER BY t.transaction_date DESC
LIMIT $2 OFFSET $3
`

type ListTransactionsByStudentParams struct {
	StudentID int32 `db:"student_id" json:"student_id"`
	Limit     int32 `db:"limit" json:"limit"`
	Offset    int32 `db:"offset" json:"offset"`
}

type ListTransactionsByStudentRow struct {
	ID              int32            `db:"id" json:"id"`
	StudentID       int32            `db:"student_id" json:"student_id"`
	BookID          int32            `db:"book_id" json:"book_id"`
	TransactionType string           `db:"transaction_type" json:"transaction_type"`
	TransactionDate pgtype.Timestamp `db:"transaction_date" json:"transaction_date"`
	DueDate         pgtype.Timestamp `db:"due_date" json:"due_date"`
	ReturnedDate    pgtype.Timestamp `db:"returned_date" json:"returned_date"`
	LibrarianID     pgtype.Int4      `db:"librarian_id" json:"librarian_id"`
	FineAmount      pgtype.Numeric   `db:"fine_amount" json:"fine_amount"`
	FinePaid        pgtype.Bool      `db:"fine_paid" json:"fine_paid"`
	Notes           pgtype.Text      `db:"notes" json:"notes"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Title           string           `db:"title" json:"title"`
	Author          string           `db:"author" json:"author"`
	BookID_2        string           `db:"book_id_2" json:"book_id_2"`
}

func (q *Queries) ListTransactionsByStudent(ctx context.Context, arg ListTransactionsByStudentParams) ([]ListTransactionsByStudentRow, error) {
	rows, err := q.db.Query(ctx, listTransactionsByStudent, arg.StudentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTransactionsByStudentRow{}
	for rows.Next() {
		var i ListTransactionsByStudentRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.BookID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.DueDate,
			&i.ReturnedDate,
			&i.LibrarianID,
			&i.FineAmount,
			&i.FinePaid,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Author,
			&i.BookID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const payTransactionFine = `-- name: PayTransactionFine :exec
UPDATE transactions
SET fine_paid = true, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) PayTransactionFine(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, payTransactionFine, id)
	return err
}

const returnBook = `-- name: ReturnBook :one
UPDATE transactions
SET returned_date = NOW(), fine_amount = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, student_id, book_id, transaction_type, transaction_date, due_date, returned_date, librarian_id, fine_amount, fine_paid, notes, created_at, updated_at
`

type ReturnBookParams struct {
	ID         int32          `db:"id" json:"id"`
	FineAmount pgtype.Numeric `db:"fine_amount" json:"fine_amount"`
}

func (q *Queries) ReturnBook(ctx context.Context, arg ReturnBookParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, returnBook, arg.ID, arg.FineAmount)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.BookID,
		&i.TransactionType,
		&i.TransactionDate,
		&i.DueDate,
		&i.ReturnedDate,
		&i.LibrarianID,
		&i.FineAmount,
		&i.FinePaid,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTransactionFine = `-- name: UpdateTransactionFine :exec
UPDATE transactions
SET fine_amount = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateTransactionFineParams struct {
	ID         int32          `db:"id" json:"id"`
	FineAmount pgtype.Numeric `db:"fine_amount" json:"fine_amount"`
}

func (q *Queries) UpdateTransactionFine(ctx context.Context, arg UpdateTransactionFineParams) error {
	_, err := q.db.Exec(ctx, updateTransactionFine, arg.ID, arg.FineAmount)
	return err
}

const updateTransactionReturn = `-- name: UpdateTransactionReturn :one
UPDATE transactions
SET returned_date = NOW(), fine_amount = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, student_id, book_id, transaction_type, transaction_date, due_date, returned_date, librarian_id, fine_amount, fine_paid, notes, created_at, updated_at
`

type UpdateTransactionReturnParams struct {
	ID         int32          `db:"id" json:"id"`
	FineAmount pgtype.Numeric `db:"fine_amount" json:"fine_amount"`
}

func (q *Queries) UpdateTransactionReturn(ctx context.Context, arg UpdateTransactionReturnParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionReturn, arg.ID, arg.FineAmount)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.BookID,
		&i.TransactionType,
		&i.TransactionDate,
		&i.DueDate,
		&i.ReturnedDate,
		&i.LibrarianID,
		&i.FineAmount,
		&i.FinePaid,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
