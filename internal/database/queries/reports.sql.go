// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reports.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBookUtilizationReport = `-- name: GetBookUtilizationReport :many
SELECT 
    b.book_id,
    b.title,
    b.author,
    b.genre,
    b.total_copies,
    b.available_copies,
    COUNT(t.id)::int as total_borrows,
    COUNT(DISTINCT t.student_id)::int as unique_borrowers,
    CASE 
        WHEN b.total_copies > 0 THEN 
            ROUND(((b.total_copies - b.available_copies)::numeric / b.total_copies::numeric) * 100, 2)::text
        ELSE '0.00'
    END as utilization_rate,
    COALESCE(MAX(t.transaction_date), b.created_at) as last_borrowed
FROM books b
LEFT JOIN transactions t ON b.id = t.book_id 
    AND t.transaction_type = 'borrow'
    AND t.transaction_date >= $1::timestamp
    AND t.transaction_date <= $2::timestamp
WHERE b.deleted_at IS NULL
    AND b.is_active = true
    AND ($3::text IS NULL OR b.genre = $3::text)
GROUP BY b.id, b.book_id, b.title, b.author, b.genre, b.total_copies, b.available_copies, b.created_at
ORDER BY total_borrows DESC, utilization_rate DESC
`

type GetBookUtilizationReportParams struct {
	Column1 pgtype.Timestamp `db:"column_1" json:"column_1"`
	Column2 pgtype.Timestamp `db:"column_2" json:"column_2"`
	Column3 string           `db:"column_3" json:"column_3"`
}

type GetBookUtilizationReportRow struct {
	BookID          string           `db:"book_id" json:"book_id"`
	Title           string           `db:"title" json:"title"`
	Author          string           `db:"author" json:"author"`
	Genre           pgtype.Text      `db:"genre" json:"genre"`
	TotalCopies     pgtype.Int4      `db:"total_copies" json:"total_copies"`
	AvailableCopies pgtype.Int4      `db:"available_copies" json:"available_copies"`
	TotalBorrows    int32            `db:"total_borrows" json:"total_borrows"`
	UniqueBorrowers int32            `db:"unique_borrowers" json:"unique_borrowers"`
	UtilizationRate string           `db:"utilization_rate" json:"utilization_rate"`
	LastBorrowed    pgtype.Timestamp `db:"last_borrowed" json:"last_borrowed"`
}

func (q *Queries) GetBookUtilizationReport(ctx context.Context, arg GetBookUtilizationReportParams) ([]GetBookUtilizationReportRow, error) {
	rows, err := q.db.Query(ctx, getBookUtilizationReport, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBookUtilizationReportRow{}
	for rows.Next() {
		var i GetBookUtilizationReportRow
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Author,
			&i.Genre,
			&i.TotalCopies,
			&i.AvailableCopies,
			&i.TotalBorrows,
			&i.UniqueBorrowers,
			&i.UtilizationRate,
			&i.LastBorrowed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBorrowingStatistics = `-- name: GetBorrowingStatistics :many
SELECT 
    TO_CHAR(DATE_TRUNC('month', t.transaction_date), 'YYYY-MM') as month,
    COUNT(CASE WHEN t.transaction_type = 'borrow' THEN 1 END)::int as total_borrows,
    COUNT(CASE WHEN t.transaction_type = 'return' THEN 1 END)::int as total_returns,
    COUNT(CASE WHEN t.due_date < NOW() AND t.returned_date IS NULL THEN 1 END)::int as total_overdue,
    COUNT(DISTINCT t.student_id)::int as unique_students
FROM transactions t
INNER JOIN students s ON t.student_id = s.id
WHERE t.transaction_date >= $1::timestamp
    AND t.transaction_date <= $2::timestamp
    AND ($3::int IS NULL OR s.year_of_study = $3::int)
    AND s.deleted_at IS NULL
GROUP BY DATE_TRUNC('month', t.transaction_date)
ORDER BY month
`

type GetBorrowingStatisticsParams struct {
	Column1 pgtype.Timestamp `db:"column_1" json:"column_1"`
	Column2 pgtype.Timestamp `db:"column_2" json:"column_2"`
	Column3 int32            `db:"column_3" json:"column_3"`
}

type GetBorrowingStatisticsRow struct {
	Month          string `db:"month" json:"month"`
	TotalBorrows   int32  `db:"total_borrows" json:"total_borrows"`
	TotalReturns   int32  `db:"total_returns" json:"total_returns"`
	TotalOverdue   int32  `db:"total_overdue" json:"total_overdue"`
	UniqueStudents int32  `db:"unique_students" json:"unique_students"`
}

func (q *Queries) GetBorrowingStatistics(ctx context.Context, arg GetBorrowingStatisticsParams) ([]GetBorrowingStatisticsRow, error) {
	rows, err := q.db.Query(ctx, getBorrowingStatistics, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBorrowingStatisticsRow{}
	for rows.Next() {
		var i GetBorrowingStatisticsRow
		if err := rows.Scan(
			&i.Month,
			&i.TotalBorrows,
			&i.TotalReturns,
			&i.TotalOverdue,
			&i.UniqueStudents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBorrowingStatisticsByDepartment = `-- name: GetBorrowingStatisticsByDepartment :many
SELECT 
    s.department,
    TO_CHAR(DATE_TRUNC('month', t.transaction_date), 'YYYY-MM') as month,
    COUNT(CASE WHEN t.transaction_type = 'borrow' THEN 1 END)::int as total_borrows,
    COUNT(CASE WHEN t.transaction_type = 'return' THEN 1 END)::int as total_returns,
    COUNT(DISTINCT t.student_id)::int as unique_students
FROM transactions t
INNER JOIN students s ON t.student_id = s.id
WHERE t.transaction_date >= $1::timestamp
    AND t.transaction_date <= $2::timestamp
    AND s.deleted_at IS NULL
    AND ($3::text IS NULL OR s.department = $3::text)
GROUP BY s.department, DATE_TRUNC('month', t.transaction_date)
ORDER BY s.department, month
`

type GetBorrowingStatisticsByDepartmentParams struct {
	Column1 pgtype.Timestamp `db:"column_1" json:"column_1"`
	Column2 pgtype.Timestamp `db:"column_2" json:"column_2"`
	Column3 string           `db:"column_3" json:"column_3"`
}

type GetBorrowingStatisticsByDepartmentRow struct {
	Department     pgtype.Text `db:"department" json:"department"`
	Month          string      `db:"month" json:"month"`
	TotalBorrows   int32       `db:"total_borrows" json:"total_borrows"`
	TotalReturns   int32       `db:"total_returns" json:"total_returns"`
	UniqueStudents int32       `db:"unique_students" json:"unique_students"`
}

func (q *Queries) GetBorrowingStatisticsByDepartment(ctx context.Context, arg GetBorrowingStatisticsByDepartmentParams) ([]GetBorrowingStatisticsByDepartmentRow, error) {
	rows, err := q.db.Query(ctx, getBorrowingStatisticsByDepartment, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBorrowingStatisticsByDepartmentRow{}
	for rows.Next() {
		var i GetBorrowingStatisticsByDepartmentRow
		if err := rows.Scan(
			&i.Department,
			&i.Month,
			&i.TotalBorrows,
			&i.TotalReturns,
			&i.UniqueStudents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBorrowingTrends = `-- name: GetBorrowingTrends :many
SELECT 
    CASE 
        WHEN $3::text = 'day' THEN TO_CHAR(DATE_TRUNC('day', t.transaction_date), 'YYYY-MM-DD')
        WHEN $3::text = 'week' THEN TO_CHAR(DATE_TRUNC('week', t.transaction_date), 'YYYY-MM-DD')
        WHEN $3::text = 'month' THEN TO_CHAR(DATE_TRUNC('month', t.transaction_date), 'YYYY-MM')
        WHEN $3::text = 'year' THEN TO_CHAR(DATE_TRUNC('year', t.transaction_date), 'YYYY')
        ELSE TO_CHAR(DATE_TRUNC('month', t.transaction_date), 'YYYY-MM')
    END as period,
    COUNT(CASE WHEN t.transaction_type = 'borrow' THEN 1 END)::int as borrow_count,
    COUNT(CASE WHEN t.transaction_type = 'return' THEN 1 END)::int as return_count,
    COUNT(CASE WHEN t.due_date < NOW() AND t.returned_date IS NULL THEN 1 END)::int as overdue_count,
    0::int as new_students,  -- Placeholder - would need separate query for new student registrations
    COUNT(DISTINCT t.student_id)::int as total_students
FROM transactions t
INNER JOIN students s ON t.student_id = s.id
WHERE t.transaction_date >= $1::timestamp
    AND t.transaction_date <= $2::timestamp
    AND s.deleted_at IS NULL
GROUP BY 
    CASE 
        WHEN $3::text = 'day' THEN TO_CHAR(DATE_TRUNC('day', t.transaction_date), 'YYYY-MM-DD')
        WHEN $3::text = 'week' THEN TO_CHAR(DATE_TRUNC('week', t.transaction_date), 'YYYY-MM-DD')
        WHEN $3::text = 'month' THEN TO_CHAR(DATE_TRUNC('month', t.transaction_date), 'YYYY-MM')
        WHEN $3::text = 'year' THEN TO_CHAR(DATE_TRUNC('year', t.transaction_date), 'YYYY')
        ELSE TO_CHAR(DATE_TRUNC('month', t.transaction_date), 'YYYY-MM')
    END
ORDER BY period
`

type GetBorrowingTrendsParams struct {
	Column1 pgtype.Timestamp `db:"column_1" json:"column_1"`
	Column2 pgtype.Timestamp `db:"column_2" json:"column_2"`
	Column3 string           `db:"column_3" json:"column_3"`
}

type GetBorrowingTrendsRow struct {
	Period        interface{} `db:"period" json:"period"`
	BorrowCount   int32       `db:"borrow_count" json:"borrow_count"`
	ReturnCount   int32       `db:"return_count" json:"return_count"`
	OverdueCount  int32       `db:"overdue_count" json:"overdue_count"`
	NewStudents   int32       `db:"new_students" json:"new_students"`
	TotalStudents int32       `db:"total_students" json:"total_students"`
}

func (q *Queries) GetBorrowingTrends(ctx context.Context, arg GetBorrowingTrendsParams) ([]GetBorrowingTrendsRow, error) {
	rows, err := q.db.Query(ctx, getBorrowingTrends, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBorrowingTrendsRow{}
	for rows.Next() {
		var i GetBorrowingTrendsRow
		if err := rows.Scan(
			&i.Period,
			&i.BorrowCount,
			&i.ReturnCount,
			&i.OverdueCount,
			&i.NewStudents,
			&i.TotalStudents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardMetrics = `-- name: GetDashboardMetrics :one
SELECT 
    (SELECT COUNT(*) FROM transactions WHERE transaction_type = 'borrow' AND DATE(transaction_date) = CURRENT_DATE)::int as today_borrows,
    (SELECT COUNT(*) FROM transactions WHERE transaction_type = 'return' AND DATE(transaction_date) = CURRENT_DATE)::int as today_returns,
    (SELECT COUNT(*) FROM transactions WHERE due_date < NOW() AND returned_date IS NULL)::int as current_overdue,
    (SELECT COUNT(*) FROM students WHERE DATE(created_at) = CURRENT_DATE AND deleted_at IS NULL)::int as new_students,
    (SELECT COUNT(DISTINCT student_id) FROM transactions WHERE DATE(transaction_date) = CURRENT_DATE)::int as active_users,
    (SELECT SUM(available_copies) FROM books WHERE deleted_at IS NULL AND is_active = true)::int as available_books,
    (SELECT COUNT(*) FROM reservations WHERE status = 'active' AND expires_at > NOW())::int as pending_reservations,
    0::int as system_alerts,  -- Placeholder for future alerts system
    NOW() as last_updated
`

type GetDashboardMetricsRow struct {
	TodayBorrows        int32       `db:"today_borrows" json:"today_borrows"`
	TodayReturns        int32       `db:"today_returns" json:"today_returns"`
	CurrentOverdue      int32       `db:"current_overdue" json:"current_overdue"`
	NewStudents         int32       `db:"new_students" json:"new_students"`
	ActiveUsers         int32       `db:"active_users" json:"active_users"`
	AvailableBooks      int32       `db:"available_books" json:"available_books"`
	PendingReservations int32       `db:"pending_reservations" json:"pending_reservations"`
	SystemAlerts        int32       `db:"system_alerts" json:"system_alerts"`
	LastUpdated         interface{} `db:"last_updated" json:"last_updated"`
}

func (q *Queries) GetDashboardMetrics(ctx context.Context) (GetDashboardMetricsRow, error) {
	row := q.db.QueryRow(ctx, getDashboardMetrics)
	var i GetDashboardMetricsRow
	err := row.Scan(
		&i.TodayBorrows,
		&i.TodayReturns,
		&i.CurrentOverdue,
		&i.NewStudents,
		&i.ActiveUsers,
		&i.AvailableBooks,
		&i.PendingReservations,
		&i.SystemAlerts,
		&i.LastUpdated,
	)
	return i, err
}

const getFineStatistics = `-- name: GetFineStatistics :one
SELECT 
    COUNT(DISTINCT t.student_id)::int as students_with_fines,
    COALESCE(SUM(t.fine_amount), 0)::text as total_fines_generated,
    COALESCE(SUM(CASE WHEN t.fine_paid = true THEN t.fine_amount ELSE 0 END), 0)::text as total_fines_paid,
    COALESCE(SUM(CASE WHEN t.fine_paid = false THEN t.fine_amount ELSE 0 END), 0)::text as total_outstanding_fines,
    COALESCE(AVG(t.fine_amount), 0)::text as avg_fine_amount
FROM transactions t
WHERE t.fine_amount > 0
    AND ($1::timestamp IS NULL OR t.transaction_date >= $1::timestamp)
    AND ($2::timestamp IS NULL OR t.transaction_date <= $2::timestamp)
`

type GetFineStatisticsParams struct {
	Column1 pgtype.Timestamp `db:"column_1" json:"column_1"`
	Column2 pgtype.Timestamp `db:"column_2" json:"column_2"`
}

type GetFineStatisticsRow struct {
	StudentsWithFines     int32  `db:"students_with_fines" json:"students_with_fines"`
	TotalFinesGenerated   string `db:"total_fines_generated" json:"total_fines_generated"`
	TotalFinesPaid        string `db:"total_fines_paid" json:"total_fines_paid"`
	TotalOutstandingFines string `db:"total_outstanding_fines" json:"total_outstanding_fines"`
	AvgFineAmount         string `db:"avg_fine_amount" json:"avg_fine_amount"`
}

func (q *Queries) GetFineStatistics(ctx context.Context, arg GetFineStatisticsParams) (GetFineStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getFineStatistics, arg.Column1, arg.Column2)
	var i GetFineStatisticsRow
	err := row.Scan(
		&i.StudentsWithFines,
		&i.TotalFinesGenerated,
		&i.TotalFinesPaid,
		&i.TotalOutstandingFines,
		&i.AvgFineAmount,
	)
	return i, err
}

const getGenrePopularity = `-- name: GetGenrePopularity :many
SELECT 
    COALESCE(b.genre, 'Uncategorized') as genre,
    COUNT(t.id)::int as total_borrows,
    COUNT(DISTINCT t.student_id)::int as unique_borrowers,
    COUNT(DISTINCT b.id)::int as unique_books,
    ROUND(COUNT(t.id)::numeric / COUNT(DISTINCT b.id)::numeric, 2)::text as avg_borrows_per_book
FROM books b
INNER JOIN transactions t ON b.id = t.book_id
WHERE t.transaction_type = 'borrow'
    AND t.transaction_date >= $1::timestamp
    AND t.transaction_date <= $2::timestamp
    AND b.deleted_at IS NULL
GROUP BY b.genre
ORDER BY total_borrows DESC
`

type GetGenrePopularityParams struct {
	Column1 pgtype.Timestamp `db:"column_1" json:"column_1"`
	Column2 pgtype.Timestamp `db:"column_2" json:"column_2"`
}

type GetGenrePopularityRow struct {
	Genre             string `db:"genre" json:"genre"`
	TotalBorrows      int32  `db:"total_borrows" json:"total_borrows"`
	UniqueBorrowers   int32  `db:"unique_borrowers" json:"unique_borrowers"`
	UniqueBooks       int32  `db:"unique_books" json:"unique_books"`
	AvgBorrowsPerBook string `db:"avg_borrows_per_book" json:"avg_borrows_per_book"`
}

func (q *Queries) GetGenrePopularity(ctx context.Context, arg GetGenrePopularityParams) ([]GetGenrePopularityRow, error) {
	rows, err := q.db.Query(ctx, getGenrePopularity, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGenrePopularityRow{}
	for rows.Next() {
		var i GetGenrePopularityRow
		if err := rows.Scan(
			&i.Genre,
			&i.TotalBorrows,
			&i.UniqueBorrowers,
			&i.UniqueBooks,
			&i.AvgBorrowsPerBook,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryStatus = `-- name: GetInventoryStatus :many
SELECT 
    COALESCE(b.genre, 'Uncategorized') as genre,
    COUNT(b.id)::int as total_books,
    SUM(b.available_copies)::int as available_books,
    COUNT(DISTINCT t.id)::int as borrowed_books,
    COUNT(DISTINCT r.id)::int as reserved_books,
    CASE 
        WHEN COUNT(b.id) > 0 THEN 
            ROUND(((COUNT(DISTINCT t.id) + COUNT(DISTINCT r.id))::numeric / COUNT(b.id)::numeric) * 100, 2)::text
        ELSE '0.00'
    END as utilization_rate
FROM books b
LEFT JOIN transactions t ON b.id = t.book_id 
    AND t.transaction_type = 'borrow' 
    AND t.returned_date IS NULL
LEFT JOIN reservations r ON b.id = r.book_id 
    AND r.status = 'active' 
    AND r.expires_at > NOW()
WHERE b.deleted_at IS NULL
    AND b.is_active = true
GROUP BY b.genre
ORDER BY total_books DESC
`

type GetInventoryStatusRow struct {
	Genre           string `db:"genre" json:"genre"`
	TotalBooks      int32  `db:"total_books" json:"total_books"`
	AvailableBooks  int32  `db:"available_books" json:"available_books"`
	BorrowedBooks   int32  `db:"borrowed_books" json:"borrowed_books"`
	ReservedBooks   int32  `db:"reserved_books" json:"reserved_books"`
	UtilizationRate string `db:"utilization_rate" json:"utilization_rate"`
}

func (q *Queries) GetInventoryStatus(ctx context.Context) ([]GetInventoryStatusRow, error) {
	rows, err := q.db.Query(ctx, getInventoryStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInventoryStatusRow{}
	for rows.Next() {
		var i GetInventoryStatusRow
		if err := rows.Scan(
			&i.Genre,
			&i.TotalBooks,
			&i.AvailableBooks,
			&i.BorrowedBooks,
			&i.ReservedBooks,
			&i.UtilizationRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLibraryOverview = `-- name: GetLibraryOverview :one
SELECT 
    (SELECT COUNT(*) FROM books WHERE deleted_at IS NULL AND is_active = true)::int as total_books,
    (SELECT COUNT(*) FROM students WHERE deleted_at IS NULL AND is_active = true)::int as total_students,
    (SELECT COUNT(*) FROM transactions WHERE transaction_type = 'borrow')::int as total_borrows,
    (SELECT COUNT(*) FROM transactions WHERE transaction_type = 'borrow' AND returned_date IS NULL)::int as active_borrows,
    (SELECT COUNT(*) FROM transactions WHERE due_date < NOW() AND returned_date IS NULL)::int as overdue_books,
    (SELECT COUNT(*) FROM reservations WHERE status = 'active' AND expires_at > NOW())::int as total_reservations,
    (SELECT SUM(available_copies) FROM books WHERE deleted_at IS NULL AND is_active = true)::int as available_books,
    (SELECT COALESCE(SUM(fine_amount)::text, '0.00') FROM transactions WHERE fine_paid = false)::text as total_fines
`

type GetLibraryOverviewRow struct {
	TotalBooks        int32  `db:"total_books" json:"total_books"`
	TotalStudents     int32  `db:"total_students" json:"total_students"`
	TotalBorrows      int32  `db:"total_borrows" json:"total_borrows"`
	ActiveBorrows     int32  `db:"active_borrows" json:"active_borrows"`
	OverdueBooks      int32  `db:"overdue_books" json:"overdue_books"`
	TotalReservations int32  `db:"total_reservations" json:"total_reservations"`
	AvailableBooks    int32  `db:"available_books" json:"available_books"`
	TotalFines        string `db:"total_fines" json:"total_fines"`
}

func (q *Queries) GetLibraryOverview(ctx context.Context) (GetLibraryOverviewRow, error) {
	row := q.db.QueryRow(ctx, getLibraryOverview)
	var i GetLibraryOverviewRow
	err := row.Scan(
		&i.TotalBooks,
		&i.TotalStudents,
		&i.TotalBorrows,
		&i.ActiveBorrows,
		&i.OverdueBooks,
		&i.TotalReservations,
		&i.AvailableBooks,
		&i.TotalFines,
	)
	return i, err
}

const getMonthlyTrends = `-- name: GetMonthlyTrends :many
SELECT 
    TO_CHAR(DATE_TRUNC('month', t.transaction_date), 'YYYY-MM') as month,
    COUNT(CASE WHEN t.transaction_type = 'borrow' THEN 1 END)::int as borrows,
    COUNT(CASE WHEN t.transaction_type = 'return' THEN 1 END)::int as returns,
    COUNT(DISTINCT t.student_id)::int as active_students,
    COALESCE(AVG(EXTRACT(DAY FROM (t.returned_date - t.transaction_date))), 0)::int as avg_loan_duration_days
FROM transactions t
WHERE t.transaction_date >= $1::timestamp
    AND t.transaction_date <= $2::timestamp
GROUP BY DATE_TRUNC('month', t.transaction_date)
ORDER BY month
`

type GetMonthlyTrendsParams struct {
	Column1 pgtype.Timestamp `db:"column_1" json:"column_1"`
	Column2 pgtype.Timestamp `db:"column_2" json:"column_2"`
}

type GetMonthlyTrendsRow struct {
	Month               string `db:"month" json:"month"`
	Borrows             int32  `db:"borrows" json:"borrows"`
	Returns             int32  `db:"returns" json:"returns"`
	ActiveStudents      int32  `db:"active_students" json:"active_students"`
	AvgLoanDurationDays int32  `db:"avg_loan_duration_days" json:"avg_loan_duration_days"`
}

func (q *Queries) GetMonthlyTrends(ctx context.Context, arg GetMonthlyTrendsParams) ([]GetMonthlyTrendsRow, error) {
	rows, err := q.db.Query(ctx, getMonthlyTrends, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMonthlyTrendsRow{}
	for rows.Next() {
		var i GetMonthlyTrendsRow
		if err := rows.Scan(
			&i.Month,
			&i.Borrows,
			&i.Returns,
			&i.ActiveStudents,
			&i.AvgLoanDurationDays,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverdueBooksByYear = `-- name: GetOverdueBooksByYear :many
SELECT 
    s.student_id,
    CONCAT(s.first_name, ' ', s.last_name) as student_name,
    s.year_of_study,
    s.department,
    b.title as book_title,
    b.author as book_author,
    t.due_date,
    EXTRACT(DAY FROM (NOW() - t.due_date))::int as days_overdue,
    COALESCE(t.fine_amount::text, '0.00') as fine_amount,
    t.id as transaction_id
FROM transactions t
INNER JOIN students s ON t.student_id = s.id
INNER JOIN books b ON t.book_id = b.id
WHERE t.due_date < NOW()
    AND t.returned_date IS NULL
    AND ($1::int IS NULL OR s.year_of_study = $1::int)
    AND ($2::text IS NULL OR s.department = $2::text)
    AND s.deleted_at IS NULL
    AND b.deleted_at IS NULL
ORDER BY t.due_date ASC
`

type GetOverdueBooksByYearParams struct {
	Column1 int32  `db:"column_1" json:"column_1"`
	Column2 string `db:"column_2" json:"column_2"`
}

type GetOverdueBooksByYearRow struct {
	StudentID     string           `db:"student_id" json:"student_id"`
	StudentName   interface{}      `db:"student_name" json:"student_name"`
	YearOfStudy   int32            `db:"year_of_study" json:"year_of_study"`
	Department    pgtype.Text      `db:"department" json:"department"`
	BookTitle     string           `db:"book_title" json:"book_title"`
	BookAuthor    string           `db:"book_author" json:"book_author"`
	DueDate       pgtype.Timestamp `db:"due_date" json:"due_date"`
	DaysOverdue   int32            `db:"days_overdue" json:"days_overdue"`
	FineAmount    interface{}      `db:"fine_amount" json:"fine_amount"`
	TransactionID int32            `db:"transaction_id" json:"transaction_id"`
}

func (q *Queries) GetOverdueBooksByYear(ctx context.Context, arg GetOverdueBooksByYearParams) ([]GetOverdueBooksByYearRow, error) {
	rows, err := q.db.Query(ctx, getOverdueBooksByYear, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOverdueBooksByYearRow{}
	for rows.Next() {
		var i GetOverdueBooksByYearRow
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentName,
			&i.YearOfStudy,
			&i.Department,
			&i.BookTitle,
			&i.BookAuthor,
			&i.DueDate,
			&i.DaysOverdue,
			&i.FineAmount,
			&i.TransactionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularBooks = `-- name: GetPopularBooks :many
SELECT 
    b.book_id,
    b.title,
    b.author,
    b.genre,
    COUNT(t.id)::int as borrow_count,
    COUNT(DISTINCT t.student_id)::int as unique_users,
    '4.5' as avg_rating  -- Placeholder for future rating system
FROM books b
INNER JOIN transactions t ON b.id = t.book_id
INNER JOIN students s ON t.student_id = s.id
WHERE t.transaction_type = 'borrow'
    AND t.transaction_date >= $1::timestamp
    AND t.transaction_date <= $2::timestamp
    AND ($4::int IS NULL OR s.year_of_study = $4::int)
    AND b.deleted_at IS NULL
    AND s.deleted_at IS NULL
GROUP BY b.id, b.book_id, b.title, b.author, b.genre
ORDER BY borrow_count DESC, unique_users DESC
LIMIT $3::int
`

type GetPopularBooksParams struct {
	Column1 pgtype.Timestamp `db:"column_1" json:"column_1"`
	Column2 pgtype.Timestamp `db:"column_2" json:"column_2"`
	Column3 int32            `db:"column_3" json:"column_3"`
	Column4 int32            `db:"column_4" json:"column_4"`
}

type GetPopularBooksRow struct {
	BookID      string      `db:"book_id" json:"book_id"`
	Title       string      `db:"title" json:"title"`
	Author      string      `db:"author" json:"author"`
	Genre       pgtype.Text `db:"genre" json:"genre"`
	BorrowCount int32       `db:"borrow_count" json:"borrow_count"`
	UniqueUsers int32       `db:"unique_users" json:"unique_users"`
	AvgRating   string      `db:"avg_rating" json:"avg_rating"`
}

func (q *Queries) GetPopularBooks(ctx context.Context, arg GetPopularBooksParams) ([]GetPopularBooksRow, error) {
	rows, err := q.db.Query(ctx, getPopularBooks,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPopularBooksRow{}
	for rows.Next() {
		var i GetPopularBooksRow
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.Author,
			&i.Genre,
			&i.BorrowCount,
			&i.UniqueUsers,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentActivity = `-- name: GetStudentActivity :many
SELECT 
    s.student_id,
    CONCAT(s.first_name, ' ', s.last_name) as student_name,
    s.year_of_study,
    s.department,
    COUNT(CASE WHEN t.transaction_type = 'borrow' THEN 1 END)::int as total_borrows,
    COUNT(CASE WHEN t.transaction_type = 'return' THEN 1 END)::int as total_returns,
    COUNT(CASE WHEN t.transaction_type = 'borrow' AND t.returned_date IS NULL THEN 1 END)::int as current_books,
    COUNT(CASE WHEN t.due_date < NOW() AND t.returned_date IS NULL THEN 1 END)::int as overdue_books,
    COALESCE(SUM(t.fine_amount)::text, '0.00') as total_fines,
    COALESCE(MAX(t.transaction_date), s.created_at) as last_activity
FROM students s
LEFT JOIN transactions t ON s.id = t.student_id 
    AND t.transaction_date >= $3::timestamp
    AND t.transaction_date <= $4::timestamp
WHERE ($1::int IS NULL OR s.year_of_study = $1::int)
    AND ($2::text IS NULL OR s.department = $2::text)
    AND s.deleted_at IS NULL
    AND s.is_active = true
GROUP BY s.id, s.student_id, s.first_name, s.last_name, s.year_of_study, s.department, s.created_at
HAVING COUNT(CASE WHEN t.transaction_type = 'borrow' THEN 1 END) > 0  -- Only include students with activity
ORDER BY total_borrows DESC, last_activity DESC
`

type GetStudentActivityParams struct {
	Column1 int32            `db:"column_1" json:"column_1"`
	Column2 string           `db:"column_2" json:"column_2"`
	Column3 pgtype.Timestamp `db:"column_3" json:"column_3"`
	Column4 pgtype.Timestamp `db:"column_4" json:"column_4"`
}

type GetStudentActivityRow struct {
	StudentID    string           `db:"student_id" json:"student_id"`
	StudentName  interface{}      `db:"student_name" json:"student_name"`
	YearOfStudy  int32            `db:"year_of_study" json:"year_of_study"`
	Department   pgtype.Text      `db:"department" json:"department"`
	TotalBorrows int32            `db:"total_borrows" json:"total_borrows"`
	TotalReturns int32            `db:"total_returns" json:"total_returns"`
	CurrentBooks int32            `db:"current_books" json:"current_books"`
	OverdueBooks int32            `db:"overdue_books" json:"overdue_books"`
	TotalFines   interface{}      `db:"total_fines" json:"total_fines"`
	LastActivity pgtype.Timestamp `db:"last_activity" json:"last_activity"`
}

func (q *Queries) GetStudentActivity(ctx context.Context, arg GetStudentActivityParams) ([]GetStudentActivityRow, error) {
	rows, err := q.db.Query(ctx, getStudentActivity,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStudentActivityRow{}
	for rows.Next() {
		var i GetStudentActivityRow
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentName,
			&i.YearOfStudy,
			&i.Department,
			&i.TotalBorrows,
			&i.TotalReturns,
			&i.CurrentBooks,
			&i.OverdueBooks,
			&i.TotalFines,
			&i.LastActivity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopBorrowingStudents = `-- name: GetTopBorrowingStudents :many
SELECT 
    s.student_id,
    CONCAT(s.first_name, ' ', s.last_name) as student_name,
    s.year_of_study,
    s.department,
    COUNT(t.id)::int as total_borrows,
    COUNT(CASE WHEN t.returned_date IS NULL THEN 1 END)::int as current_books,
    COUNT(CASE WHEN t.due_date < NOW() AND t.returned_date IS NULL THEN 1 END)::int as overdue_books
FROM students s
INNER JOIN transactions t ON s.id = t.student_id
WHERE t.transaction_type = 'borrow'
    AND t.transaction_date >= $1::timestamp
    AND t.transaction_date <= $2::timestamp
    AND s.deleted_at IS NULL
    AND ($3::int IS NULL OR s.year_of_study = $3::int)
GROUP BY s.id, s.student_id, s.first_name, s.last_name, s.year_of_study, s.department
ORDER BY total_borrows DESC
LIMIT $4::int
`

type GetTopBorrowingStudentsParams struct {
	Column1 pgtype.Timestamp `db:"column_1" json:"column_1"`
	Column2 pgtype.Timestamp `db:"column_2" json:"column_2"`
	Column3 int32            `db:"column_3" json:"column_3"`
	Column4 int32            `db:"column_4" json:"column_4"`
}

type GetTopBorrowingStudentsRow struct {
	StudentID    string      `db:"student_id" json:"student_id"`
	StudentName  interface{} `db:"student_name" json:"student_name"`
	YearOfStudy  int32       `db:"year_of_study" json:"year_of_study"`
	Department   pgtype.Text `db:"department" json:"department"`
	TotalBorrows int32       `db:"total_borrows" json:"total_borrows"`
	CurrentBooks int32       `db:"current_books" json:"current_books"`
	OverdueBooks int32       `db:"overdue_books" json:"overdue_books"`
}

func (q *Queries) GetTopBorrowingStudents(ctx context.Context, arg GetTopBorrowingStudentsParams) ([]GetTopBorrowingStudentsRow, error) {
	rows, err := q.db.Query(ctx, getTopBorrowingStudents,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopBorrowingStudentsRow{}
	for rows.Next() {
		var i GetTopBorrowingStudentsRow
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentName,
			&i.YearOfStudy,
			&i.Department,
			&i.TotalBorrows,
			&i.CurrentBooks,
			&i.OverdueBooks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getYearlyStatistics = `-- name: GetYearlyStatistics :many
SELECT 
    EXTRACT(YEAR FROM t.transaction_date)::int as year,
    COUNT(CASE WHEN t.transaction_type = 'borrow' THEN 1 END)::int as total_borrows,
    COUNT(CASE WHEN t.transaction_type = 'return' THEN 1 END)::int as total_returns,
    COUNT(CASE WHEN t.due_date < NOW() AND t.returned_date IS NULL THEN 1 END)::int as total_overdue,
    COUNT(DISTINCT s.id)::int as total_students,
    (SELECT COUNT(*) FROM books WHERE deleted_at IS NULL)::int as total_books,
    CASE 
        WHEN COUNT(DISTINCT s.id) > 0 THEN 
            ROUND(COUNT(CASE WHEN t.transaction_type = 'borrow' THEN 1 END)::numeric / COUNT(DISTINCT s.id)::numeric, 2)::text
        ELSE '0.00'
    END as avg_borrows_per_student
FROM transactions t
INNER JOIN students s ON t.student_id = s.id
WHERE EXTRACT(YEAR FROM t.transaction_date) = ANY($1::int[])
    AND s.deleted_at IS NULL
GROUP BY EXTRACT(YEAR FROM t.transaction_date)
ORDER BY year
`

type GetYearlyStatisticsRow struct {
	Year                 int32  `db:"year" json:"year"`
	TotalBorrows         int32  `db:"total_borrows" json:"total_borrows"`
	TotalReturns         int32  `db:"total_returns" json:"total_returns"`
	TotalOverdue         int32  `db:"total_overdue" json:"total_overdue"`
	TotalStudents        int32  `db:"total_students" json:"total_students"`
	TotalBooks           int32  `db:"total_books" json:"total_books"`
	AvgBorrowsPerStudent string `db:"avg_borrows_per_student" json:"avg_borrows_per_student"`
}

func (q *Queries) GetYearlyStatistics(ctx context.Context, dollar_1 []int32) ([]GetYearlyStatisticsRow, error) {
	rows, err := q.db.Query(ctx, getYearlyStatistics, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetYearlyStatisticsRow{}
	for rows.Next() {
		var i GetYearlyStatisticsRow
		if err := rows.Scan(
			&i.Year,
			&i.TotalBorrows,
			&i.TotalReturns,
			&i.TotalOverdue,
			&i.TotalStudents,
			&i.TotalBooks,
			&i.AvgBorrowsPerStudent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
