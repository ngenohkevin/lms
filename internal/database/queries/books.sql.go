// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: books.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAvailableBooks = `-- name: CountAvailableBooks :one
SELECT COUNT(*) FROM books
WHERE available_copies > 0 AND deleted_at IS NULL
`

func (q *Queries) CountAvailableBooks(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAvailableBooks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBooks = `-- name: CountBooks :one
SELECT COUNT(*) FROM books
WHERE deleted_at IS NULL
`

func (q *Queries) CountBooks(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countBooks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBook = `-- name: CreateBook :one
INSERT INTO books (book_id, isbn, title, author, publisher, published_year, genre, description, cover_image_url, total_copies, available_copies, shelf_location)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, book_id, isbn, title, author, publisher, published_year, genre, description, cover_image_url, total_copies, available_copies, shelf_location, is_active, deleted_at, created_at, updated_at, condition
`

type CreateBookParams struct {
	BookID          string      `db:"book_id" json:"book_id"`
	Isbn            pgtype.Text `db:"isbn" json:"isbn"`
	Title           string      `db:"title" json:"title"`
	Author          string      `db:"author" json:"author"`
	Publisher       pgtype.Text `db:"publisher" json:"publisher"`
	PublishedYear   pgtype.Int4 `db:"published_year" json:"published_year"`
	Genre           pgtype.Text `db:"genre" json:"genre"`
	Description     pgtype.Text `db:"description" json:"description"`
	CoverImageUrl   pgtype.Text `db:"cover_image_url" json:"cover_image_url"`
	TotalCopies     pgtype.Int4 `db:"total_copies" json:"total_copies"`
	AvailableCopies pgtype.Int4 `db:"available_copies" json:"available_copies"`
	ShelfLocation   pgtype.Text `db:"shelf_location" json:"shelf_location"`
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (Book, error) {
	row := q.db.QueryRow(ctx, createBook,
		arg.BookID,
		arg.Isbn,
		arg.Title,
		arg.Author,
		arg.Publisher,
		arg.PublishedYear,
		arg.Genre,
		arg.Description,
		arg.CoverImageUrl,
		arg.TotalCopies,
		arg.AvailableCopies,
		arg.ShelfLocation,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Isbn,
		&i.Title,
		&i.Author,
		&i.Publisher,
		&i.PublishedYear,
		&i.Genre,
		&i.Description,
		&i.CoverImageUrl,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.ShelfLocation,
		&i.IsActive,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Condition,
	)
	return i, err
}

const getBookByBookID = `-- name: GetBookByBookID :one
SELECT id, book_id, isbn, title, author, publisher, published_year, genre, description, cover_image_url, total_copies, available_copies, shelf_location, is_active, deleted_at, created_at, updated_at, condition FROM books
WHERE book_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetBookByBookID(ctx context.Context, bookID string) (Book, error) {
	row := q.db.QueryRow(ctx, getBookByBookID, bookID)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Isbn,
		&i.Title,
		&i.Author,
		&i.Publisher,
		&i.PublishedYear,
		&i.Genre,
		&i.Description,
		&i.CoverImageUrl,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.ShelfLocation,
		&i.IsActive,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Condition,
	)
	return i, err
}

const getBookByID = `-- name: GetBookByID :one
SELECT id, book_id, isbn, title, author, publisher, published_year, genre, description, cover_image_url, total_copies, available_copies, shelf_location, is_active, deleted_at, created_at, updated_at, condition FROM books
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetBookByID(ctx context.Context, id int32) (Book, error) {
	row := q.db.QueryRow(ctx, getBookByID, id)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Isbn,
		&i.Title,
		&i.Author,
		&i.Publisher,
		&i.PublishedYear,
		&i.Genre,
		&i.Description,
		&i.CoverImageUrl,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.ShelfLocation,
		&i.IsActive,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Condition,
	)
	return i, err
}

const getBookByISBN = `-- name: GetBookByISBN :one
SELECT id, book_id, isbn, title, author, publisher, published_year, genre, description, cover_image_url, total_copies, available_copies, shelf_location, is_active, deleted_at, created_at, updated_at, condition FROM books
WHERE isbn = $1 AND deleted_at IS NULL
`

func (q *Queries) GetBookByISBN(ctx context.Context, isbn pgtype.Text) (Book, error) {
	row := q.db.QueryRow(ctx, getBookByISBN, isbn)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Isbn,
		&i.Title,
		&i.Author,
		&i.Publisher,
		&i.PublishedYear,
		&i.Genre,
		&i.Description,
		&i.CoverImageUrl,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.ShelfLocation,
		&i.IsActive,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Condition,
	)
	return i, err
}

const listAvailableBooks = `-- name: ListAvailableBooks :many
SELECT id, book_id, isbn, title, author, publisher, published_year, genre, description, cover_image_url, total_copies, available_copies, shelf_location, is_active, deleted_at, created_at, updated_at, condition FROM books
WHERE available_copies > 0 AND deleted_at IS NULL
ORDER BY title
LIMIT $1 OFFSET $2
`

type ListAvailableBooksParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListAvailableBooks(ctx context.Context, arg ListAvailableBooksParams) ([]Book, error) {
	rows, err := q.db.Query(ctx, listAvailableBooks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Book{}
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.Isbn,
			&i.Title,
			&i.Author,
			&i.Publisher,
			&i.PublishedYear,
			&i.Genre,
			&i.Description,
			&i.CoverImageUrl,
			&i.TotalCopies,
			&i.AvailableCopies,
			&i.ShelfLocation,
			&i.IsActive,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Condition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooks = `-- name: ListBooks :many
SELECT id, book_id, isbn, title, author, publisher, published_year, genre, description, cover_image_url, total_copies, available_copies, shelf_location, is_active, deleted_at, created_at, updated_at, condition FROM books
WHERE deleted_at IS NULL
ORDER BY title
LIMIT $1 OFFSET $2
`

type ListBooksParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListBooks(ctx context.Context, arg ListBooksParams) ([]Book, error) {
	rows, err := q.db.Query(ctx, listBooks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Book{}
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.Isbn,
			&i.Title,
			&i.Author,
			&i.Publisher,
			&i.PublishedYear,
			&i.Genre,
			&i.Description,
			&i.CoverImageUrl,
			&i.TotalCopies,
			&i.AvailableCopies,
			&i.ShelfLocation,
			&i.IsActive,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Condition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBooks = `-- name: SearchBooks :many
SELECT id, book_id, isbn, title, author, publisher, published_year, genre, description, cover_image_url, total_copies, available_copies, shelf_location, is_active, deleted_at, created_at, updated_at, condition FROM books
WHERE (title ILIKE $1 OR author ILIKE $1 OR book_id ILIKE $1 OR isbn ILIKE $1)
AND deleted_at IS NULL
ORDER BY title
LIMIT $2 OFFSET $3
`

type SearchBooksParams struct {
	Title  string `db:"title" json:"title"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) SearchBooks(ctx context.Context, arg SearchBooksParams) ([]Book, error) {
	rows, err := q.db.Query(ctx, searchBooks, arg.Title, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Book{}
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.Isbn,
			&i.Title,
			&i.Author,
			&i.Publisher,
			&i.PublishedYear,
			&i.Genre,
			&i.Description,
			&i.CoverImageUrl,
			&i.TotalCopies,
			&i.AvailableCopies,
			&i.ShelfLocation,
			&i.IsActive,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Condition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBooksByGenre = `-- name: SearchBooksByGenre :many
SELECT id, book_id, isbn, title, author, publisher, published_year, genre, description, cover_image_url, total_copies, available_copies, shelf_location, is_active, deleted_at, created_at, updated_at, condition FROM books
WHERE genre = $1 AND deleted_at IS NULL
ORDER BY title
LIMIT $2 OFFSET $3
`

type SearchBooksByGenreParams struct {
	Genre  pgtype.Text `db:"genre" json:"genre"`
	Limit  int32       `db:"limit" json:"limit"`
	Offset int32       `db:"offset" json:"offset"`
}

func (q *Queries) SearchBooksByGenre(ctx context.Context, arg SearchBooksByGenreParams) ([]Book, error) {
	rows, err := q.db.Query(ctx, searchBooksByGenre, arg.Genre, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Book{}
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.Isbn,
			&i.Title,
			&i.Author,
			&i.Publisher,
			&i.PublishedYear,
			&i.Genre,
			&i.Description,
			&i.CoverImageUrl,
			&i.TotalCopies,
			&i.AvailableCopies,
			&i.ShelfLocation,
			&i.IsActive,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Condition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteBook = `-- name: SoftDeleteBook :exec
UPDATE books
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteBook(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, softDeleteBook, id)
	return err
}

const updateBook = `-- name: UpdateBook :one
UPDATE books
SET book_id = $2, isbn = $3, title = $4, author = $5, publisher = $6, published_year = $7, genre = $8, description = $9, cover_image_url = $10, total_copies = $11, available_copies = $12, shelf_location = $13, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, book_id, isbn, title, author, publisher, published_year, genre, description, cover_image_url, total_copies, available_copies, shelf_location, is_active, deleted_at, created_at, updated_at, condition
`

type UpdateBookParams struct {
	ID              int32       `db:"id" json:"id"`
	BookID          string      `db:"book_id" json:"book_id"`
	Isbn            pgtype.Text `db:"isbn" json:"isbn"`
	Title           string      `db:"title" json:"title"`
	Author          string      `db:"author" json:"author"`
	Publisher       pgtype.Text `db:"publisher" json:"publisher"`
	PublishedYear   pgtype.Int4 `db:"published_year" json:"published_year"`
	Genre           pgtype.Text `db:"genre" json:"genre"`
	Description     pgtype.Text `db:"description" json:"description"`
	CoverImageUrl   pgtype.Text `db:"cover_image_url" json:"cover_image_url"`
	TotalCopies     pgtype.Int4 `db:"total_copies" json:"total_copies"`
	AvailableCopies pgtype.Int4 `db:"available_copies" json:"available_copies"`
	ShelfLocation   pgtype.Text `db:"shelf_location" json:"shelf_location"`
}

func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) (Book, error) {
	row := q.db.QueryRow(ctx, updateBook,
		arg.ID,
		arg.BookID,
		arg.Isbn,
		arg.Title,
		arg.Author,
		arg.Publisher,
		arg.PublishedYear,
		arg.Genre,
		arg.Description,
		arg.CoverImageUrl,
		arg.TotalCopies,
		arg.AvailableCopies,
		arg.ShelfLocation,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.Isbn,
		&i.Title,
		&i.Author,
		&i.Publisher,
		&i.PublishedYear,
		&i.Genre,
		&i.Description,
		&i.CoverImageUrl,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.ShelfLocation,
		&i.IsActive,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Condition,
	)
	return i, err
}

const updateBookAvailability = `-- name: UpdateBookAvailability :exec
UPDATE books
SET available_copies = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateBookAvailabilityParams struct {
	ID              int32       `db:"id" json:"id"`
	AvailableCopies pgtype.Int4 `db:"available_copies" json:"available_copies"`
}

func (q *Queries) UpdateBookAvailability(ctx context.Context, arg UpdateBookAvailabilityParams) error {
	_, err := q.db.Exec(ctx, updateBookAvailability, arg.ID, arg.AvailableCopies)
	return err
}

const updateBookCondition = `-- name: UpdateBookCondition :exec
UPDATE books
SET condition = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateBookConditionParams struct {
	ID        int32       `db:"id" json:"id"`
	Condition pgtype.Text `db:"condition" json:"condition"`
}

func (q *Queries) UpdateBookCondition(ctx context.Context, arg UpdateBookConditionParams) error {
	_, err := q.db.Exec(ctx, updateBookCondition, arg.ID, arg.Condition)
	return err
}
