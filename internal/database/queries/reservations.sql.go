// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reservations.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelReservation = `-- name: CancelReservation :one
UPDATE reservations
SET status = 'cancelled', updated_at = NOW()
WHERE id = $1
RETURNING id, student_id, book_id, reserved_at, expires_at, status, fulfilled_at, created_at, updated_at
`

func (q *Queries) CancelReservation(ctx context.Context, id int32) (Reservation, error) {
	row := q.db.QueryRow(ctx, cancelReservation, id)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.BookID,
		&i.ReservedAt,
		&i.ExpiresAt,
		&i.Status,
		&i.FulfilledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countActiveReservationsByBook = `-- name: CountActiveReservationsByBook :one
SELECT COUNT(*) FROM reservations
WHERE book_id = $1 AND status = 'active'
`

func (q *Queries) CountActiveReservationsByBook(ctx context.Context, bookID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveReservationsByBook, bookID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActiveReservationsByStudent = `-- name: CountActiveReservationsByStudent :one
SELECT COUNT(*) FROM reservations
WHERE student_id = $1 AND status = 'active'
`

func (q *Queries) CountActiveReservationsByStudent(ctx context.Context, studentID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveReservationsByStudent, studentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReservation = `-- name: CreateReservation :one
INSERT INTO reservations (student_id, book_id, expires_at)
VALUES ($1, $2, $3)
RETURNING id, student_id, book_id, reserved_at, expires_at, status, fulfilled_at, created_at, updated_at
`

type CreateReservationParams struct {
	StudentID int32            `db:"student_id" json:"student_id"`
	BookID    int32            `db:"book_id" json:"book_id"`
	ExpiresAt pgtype.Timestamp `db:"expires_at" json:"expires_at"`
}

func (q *Queries) CreateReservation(ctx context.Context, arg CreateReservationParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, createReservation, arg.StudentID, arg.BookID, arg.ExpiresAt)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.BookID,
		&i.ReservedAt,
		&i.ExpiresAt,
		&i.Status,
		&i.FulfilledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNextReservationForBook = `-- name: GetNextReservationForBook :one
SELECT r.id, r.student_id, r.book_id, r.reserved_at, r.expires_at, r.status, r.fulfilled_at, r.created_at, r.updated_at, s.first_name, s.last_name, s.student_id
FROM reservations r
JOIN students s ON r.student_id = s.id
WHERE r.book_id = $1 AND r.status = 'active'
ORDER BY r.reserved_at ASC
LIMIT 1
`

type GetNextReservationForBookRow struct {
	ID          int32            `db:"id" json:"id"`
	StudentID   int32            `db:"student_id" json:"student_id"`
	BookID      int32            `db:"book_id" json:"book_id"`
	ReservedAt  pgtype.Timestamp `db:"reserved_at" json:"reserved_at"`
	ExpiresAt   pgtype.Timestamp `db:"expires_at" json:"expires_at"`
	Status      pgtype.Text      `db:"status" json:"status"`
	FulfilledAt pgtype.Timestamp `db:"fulfilled_at" json:"fulfilled_at"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	FirstName   string           `db:"first_name" json:"first_name"`
	LastName    string           `db:"last_name" json:"last_name"`
	StudentID_2 string           `db:"student_id_2" json:"student_id_2"`
}

func (q *Queries) GetNextReservationForBook(ctx context.Context, bookID int32) (GetNextReservationForBookRow, error) {
	row := q.db.QueryRow(ctx, getNextReservationForBook, bookID)
	var i GetNextReservationForBookRow
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.BookID,
		&i.ReservedAt,
		&i.ExpiresAt,
		&i.Status,
		&i.FulfilledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstName,
		&i.LastName,
		&i.StudentID_2,
	)
	return i, err
}

const getReservationByID = `-- name: GetReservationByID :one
SELECT r.id, r.student_id, r.book_id, r.reserved_at, r.expires_at, r.status, r.fulfilled_at, r.created_at, r.updated_at, s.first_name, s.last_name, s.student_id, b.title, b.author, b.book_id
FROM reservations r
JOIN students s ON r.student_id = s.id
JOIN books b ON r.book_id = b.id
WHERE r.id = $1
`

type GetReservationByIDRow struct {
	ID          int32            `db:"id" json:"id"`
	StudentID   int32            `db:"student_id" json:"student_id"`
	BookID      int32            `db:"book_id" json:"book_id"`
	ReservedAt  pgtype.Timestamp `db:"reserved_at" json:"reserved_at"`
	ExpiresAt   pgtype.Timestamp `db:"expires_at" json:"expires_at"`
	Status      pgtype.Text      `db:"status" json:"status"`
	FulfilledAt pgtype.Timestamp `db:"fulfilled_at" json:"fulfilled_at"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	FirstName   string           `db:"first_name" json:"first_name"`
	LastName    string           `db:"last_name" json:"last_name"`
	StudentID_2 string           `db:"student_id_2" json:"student_id_2"`
	Title       string           `db:"title" json:"title"`
	Author      string           `db:"author" json:"author"`
	BookID_2    string           `db:"book_id_2" json:"book_id_2"`
}

func (q *Queries) GetReservationByID(ctx context.Context, id int32) (GetReservationByIDRow, error) {
	row := q.db.QueryRow(ctx, getReservationByID, id)
	var i GetReservationByIDRow
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.BookID,
		&i.ReservedAt,
		&i.ExpiresAt,
		&i.Status,
		&i.FulfilledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstName,
		&i.LastName,
		&i.StudentID_2,
		&i.Title,
		&i.Author,
		&i.BookID_2,
	)
	return i, err
}

const listActiveReservations = `-- name: ListActiveReservations :many
SELECT r.id, r.student_id, r.book_id, r.reserved_at, r.expires_at, r.status, r.fulfilled_at, r.created_at, r.updated_at, s.first_name, s.last_name, s.student_id, b.title, b.author, b.book_id
FROM reservations r
JOIN students s ON r.student_id = s.id
JOIN books b ON r.book_id = b.id
WHERE r.status = 'active'
ORDER BY r.reserved_at ASC
`

type ListActiveReservationsRow struct {
	ID          int32            `db:"id" json:"id"`
	StudentID   int32            `db:"student_id" json:"student_id"`
	BookID      int32            `db:"book_id" json:"book_id"`
	ReservedAt  pgtype.Timestamp `db:"reserved_at" json:"reserved_at"`
	ExpiresAt   pgtype.Timestamp `db:"expires_at" json:"expires_at"`
	Status      pgtype.Text      `db:"status" json:"status"`
	FulfilledAt pgtype.Timestamp `db:"fulfilled_at" json:"fulfilled_at"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	FirstName   string           `db:"first_name" json:"first_name"`
	LastName    string           `db:"last_name" json:"last_name"`
	StudentID_2 string           `db:"student_id_2" json:"student_id_2"`
	Title       string           `db:"title" json:"title"`
	Author      string           `db:"author" json:"author"`
	BookID_2    string           `db:"book_id_2" json:"book_id_2"`
}

func (q *Queries) ListActiveReservations(ctx context.Context) ([]ListActiveReservationsRow, error) {
	rows, err := q.db.Query(ctx, listActiveReservations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveReservationsRow{}
	for rows.Next() {
		var i ListActiveReservationsRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.BookID,
			&i.ReservedAt,
			&i.ExpiresAt,
			&i.Status,
			&i.FulfilledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.StudentID_2,
			&i.Title,
			&i.Author,
			&i.BookID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpiredReservations = `-- name: ListExpiredReservations :many
SELECT r.id, r.student_id, r.book_id, r.reserved_at, r.expires_at, r.status, r.fulfilled_at, r.created_at, r.updated_at, s.first_name, s.last_name, s.student_id, b.title, b.author, b.book_id
FROM reservations r
JOIN students s ON r.student_id = s.id
JOIN books b ON r.book_id = b.id
WHERE r.expires_at < NOW() AND r.status = 'active'
ORDER BY r.expires_at ASC
`

type ListExpiredReservationsRow struct {
	ID          int32            `db:"id" json:"id"`
	StudentID   int32            `db:"student_id" json:"student_id"`
	BookID      int32            `db:"book_id" json:"book_id"`
	ReservedAt  pgtype.Timestamp `db:"reserved_at" json:"reserved_at"`
	ExpiresAt   pgtype.Timestamp `db:"expires_at" json:"expires_at"`
	Status      pgtype.Text      `db:"status" json:"status"`
	FulfilledAt pgtype.Timestamp `db:"fulfilled_at" json:"fulfilled_at"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	FirstName   string           `db:"first_name" json:"first_name"`
	LastName    string           `db:"last_name" json:"last_name"`
	StudentID_2 string           `db:"student_id_2" json:"student_id_2"`
	Title       string           `db:"title" json:"title"`
	Author      string           `db:"author" json:"author"`
	BookID_2    string           `db:"book_id_2" json:"book_id_2"`
}

func (q *Queries) ListExpiredReservations(ctx context.Context) ([]ListExpiredReservationsRow, error) {
	rows, err := q.db.Query(ctx, listExpiredReservations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExpiredReservationsRow{}
	for rows.Next() {
		var i ListExpiredReservationsRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.BookID,
			&i.ReservedAt,
			&i.ExpiresAt,
			&i.Status,
			&i.FulfilledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.StudentID_2,
			&i.Title,
			&i.Author,
			&i.BookID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservations = `-- name: ListReservations :many
SELECT r.id, r.student_id, r.book_id, r.reserved_at, r.expires_at, r.status, r.fulfilled_at, r.created_at, r.updated_at, s.first_name, s.last_name, s.student_id, b.title, b.author, b.book_id
FROM reservations r
JOIN students s ON r.student_id = s.id
JOIN books b ON r.book_id = b.id
ORDER BY r.reserved_at ASC
LIMIT $1 OFFSET $2
`

type ListReservationsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListReservationsRow struct {
	ID          int32            `db:"id" json:"id"`
	StudentID   int32            `db:"student_id" json:"student_id"`
	BookID      int32            `db:"book_id" json:"book_id"`
	ReservedAt  pgtype.Timestamp `db:"reserved_at" json:"reserved_at"`
	ExpiresAt   pgtype.Timestamp `db:"expires_at" json:"expires_at"`
	Status      pgtype.Text      `db:"status" json:"status"`
	FulfilledAt pgtype.Timestamp `db:"fulfilled_at" json:"fulfilled_at"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	FirstName   string           `db:"first_name" json:"first_name"`
	LastName    string           `db:"last_name" json:"last_name"`
	StudentID_2 string           `db:"student_id_2" json:"student_id_2"`
	Title       string           `db:"title" json:"title"`
	Author      string           `db:"author" json:"author"`
	BookID_2    string           `db:"book_id_2" json:"book_id_2"`
}

func (q *Queries) ListReservations(ctx context.Context, arg ListReservationsParams) ([]ListReservationsRow, error) {
	rows, err := q.db.Query(ctx, listReservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReservationsRow{}
	for rows.Next() {
		var i ListReservationsRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.BookID,
			&i.ReservedAt,
			&i.ExpiresAt,
			&i.Status,
			&i.FulfilledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.StudentID_2,
			&i.Title,
			&i.Author,
			&i.BookID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByBook = `-- name: ListReservationsByBook :many
SELECT r.id, r.student_id, r.book_id, r.reserved_at, r.expires_at, r.status, r.fulfilled_at, r.created_at, r.updated_at, s.first_name, s.last_name, s.student_id
FROM reservations r
JOIN students s ON r.student_id = s.id
WHERE r.book_id = $1 AND r.status = 'active'
ORDER BY r.reserved_at ASC
`

type ListReservationsByBookRow struct {
	ID          int32            `db:"id" json:"id"`
	StudentID   int32            `db:"student_id" json:"student_id"`
	BookID      int32            `db:"book_id" json:"book_id"`
	ReservedAt  pgtype.Timestamp `db:"reserved_at" json:"reserved_at"`
	ExpiresAt   pgtype.Timestamp `db:"expires_at" json:"expires_at"`
	Status      pgtype.Text      `db:"status" json:"status"`
	FulfilledAt pgtype.Timestamp `db:"fulfilled_at" json:"fulfilled_at"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	FirstName   string           `db:"first_name" json:"first_name"`
	LastName    string           `db:"last_name" json:"last_name"`
	StudentID_2 string           `db:"student_id_2" json:"student_id_2"`
}

func (q *Queries) ListReservationsByBook(ctx context.Context, bookID int32) ([]ListReservationsByBookRow, error) {
	rows, err := q.db.Query(ctx, listReservationsByBook, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReservationsByBookRow{}
	for rows.Next() {
		var i ListReservationsByBookRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.BookID,
			&i.ReservedAt,
			&i.ExpiresAt,
			&i.Status,
			&i.FulfilledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.StudentID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByStudent = `-- name: ListReservationsByStudent :many
SELECT r.id, r.student_id, r.book_id, r.reserved_at, r.expires_at, r.status, r.fulfilled_at, r.created_at, r.updated_at, b.title, b.author, b.book_id
FROM reservations r
JOIN books b ON r.book_id = b.id
WHERE r.student_id = $1
ORDER BY r.reserved_at DESC
LIMIT $2 OFFSET $3
`

type ListReservationsByStudentParams struct {
	StudentID int32 `db:"student_id" json:"student_id"`
	Limit     int32 `db:"limit" json:"limit"`
	Offset    int32 `db:"offset" json:"offset"`
}

type ListReservationsByStudentRow struct {
	ID          int32            `db:"id" json:"id"`
	StudentID   int32            `db:"student_id" json:"student_id"`
	BookID      int32            `db:"book_id" json:"book_id"`
	ReservedAt  pgtype.Timestamp `db:"reserved_at" json:"reserved_at"`
	ExpiresAt   pgtype.Timestamp `db:"expires_at" json:"expires_at"`
	Status      pgtype.Text      `db:"status" json:"status"`
	FulfilledAt pgtype.Timestamp `db:"fulfilled_at" json:"fulfilled_at"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Title       string           `db:"title" json:"title"`
	Author      string           `db:"author" json:"author"`
	BookID_2    string           `db:"book_id_2" json:"book_id_2"`
}

func (q *Queries) ListReservationsByStudent(ctx context.Context, arg ListReservationsByStudentParams) ([]ListReservationsByStudentRow, error) {
	rows, err := q.db.Query(ctx, listReservationsByStudent, arg.StudentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReservationsByStudentRow{}
	for rows.Next() {
		var i ListReservationsByStudentRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.BookID,
			&i.ReservedAt,
			&i.ExpiresAt,
			&i.Status,
			&i.FulfilledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Author,
			&i.BookID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReservationStatus = `-- name: UpdateReservationStatus :one
UPDATE reservations
SET status = $2, fulfilled_at = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, student_id, book_id, reserved_at, expires_at, status, fulfilled_at, created_at, updated_at
`

type UpdateReservationStatusParams struct {
	ID          int32            `db:"id" json:"id"`
	Status      pgtype.Text      `db:"status" json:"status"`
	FulfilledAt pgtype.Timestamp `db:"fulfilled_at" json:"fulfilled_at"`
}

func (q *Queries) UpdateReservationStatus(ctx context.Context, arg UpdateReservationStatusParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, updateReservationStatus, arg.ID, arg.Status, arg.FulfilledAt)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.BookID,
		&i.ReservedAt,
		&i.ExpiresAt,
		&i.Status,
		&i.FulfilledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
