// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: email_deliveries.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEmailDelivery = `-- name: CreateEmailDelivery :one

INSERT INTO email_deliveries (
    notification_id, 
    email_address, 
    status, 
    retry_count, 
    max_retries,
    delivery_metadata
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, notification_id, email_address, status, sent_at, delivered_at, failed_at, error_message, retry_count, max_retries, provider_message_id, delivery_metadata, created_at, updated_at
`

type CreateEmailDeliveryParams struct {
	NotificationID   int32       `db:"notification_id" json:"notification_id"`
	EmailAddress     string      `db:"email_address" json:"email_address"`
	Status           string      `db:"status" json:"status"`
	RetryCount       pgtype.Int4 `db:"retry_count" json:"retry_count"`
	MaxRetries       pgtype.Int4 `db:"max_retries" json:"max_retries"`
	DeliveryMetadata []byte      `db:"delivery_metadata" json:"delivery_metadata"`
}

// Email Deliveries Queries
// Phase 7.4: Email Integration - Delivery Tracking
func (q *Queries) CreateEmailDelivery(ctx context.Context, arg CreateEmailDeliveryParams) (EmailDelivery, error) {
	row := q.db.QueryRow(ctx, createEmailDelivery,
		arg.NotificationID,
		arg.EmailAddress,
		arg.Status,
		arg.RetryCount,
		arg.MaxRetries,
		arg.DeliveryMetadata,
	)
	var i EmailDelivery
	err := row.Scan(
		&i.ID,
		&i.NotificationID,
		&i.EmailAddress,
		&i.Status,
		&i.SentAt,
		&i.DeliveredAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ProviderMessageID,
		&i.DeliveryMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOldEmailDeliveries = `-- name: DeleteOldEmailDeliveries :exec
DELETE FROM email_deliveries 
WHERE created_at < $1 AND status IN ('delivered', 'bounced')
`

func (q *Queries) DeleteOldEmailDeliveries(ctx context.Context, createdAt pgtype.Timestamp) error {
	_, err := q.db.Exec(ctx, deleteOldEmailDeliveries, createdAt)
	return err
}

const getEmailDeliveriesByNotification = `-- name: GetEmailDeliveriesByNotification :many
SELECT id, notification_id, email_address, status, sent_at, delivered_at, failed_at, error_message, retry_count, max_retries, provider_message_id, delivery_metadata, created_at, updated_at FROM email_deliveries WHERE notification_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetEmailDeliveriesByNotification(ctx context.Context, notificationID int32) ([]EmailDelivery, error) {
	rows, err := q.db.Query(ctx, getEmailDeliveriesByNotification, notificationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EmailDelivery{}
	for rows.Next() {
		var i EmailDelivery
		if err := rows.Scan(
			&i.ID,
			&i.NotificationID,
			&i.EmailAddress,
			&i.Status,
			&i.SentAt,
			&i.DeliveredAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.ProviderMessageID,
			&i.DeliveryMetadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailDeliveriesByStatus = `-- name: GetEmailDeliveriesByStatus :many
SELECT id, notification_id, email_address, status, sent_at, delivered_at, failed_at, error_message, retry_count, max_retries, provider_message_id, delivery_metadata, created_at, updated_at FROM email_deliveries 
WHERE status = $1 
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetEmailDeliveriesByStatusParams struct {
	Status string `db:"status" json:"status"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetEmailDeliveriesByStatus(ctx context.Context, arg GetEmailDeliveriesByStatusParams) ([]EmailDelivery, error) {
	rows, err := q.db.Query(ctx, getEmailDeliveriesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EmailDelivery{}
	for rows.Next() {
		var i EmailDelivery
		if err := rows.Scan(
			&i.ID,
			&i.NotificationID,
			&i.EmailAddress,
			&i.Status,
			&i.SentAt,
			&i.DeliveredAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.ProviderMessageID,
			&i.DeliveryMetadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailDelivery = `-- name: GetEmailDelivery :one
SELECT id, notification_id, email_address, status, sent_at, delivered_at, failed_at, error_message, retry_count, max_retries, provider_message_id, delivery_metadata, created_at, updated_at FROM email_deliveries WHERE id = $1
`

func (q *Queries) GetEmailDelivery(ctx context.Context, id int32) (EmailDelivery, error) {
	row := q.db.QueryRow(ctx, getEmailDelivery, id)
	var i EmailDelivery
	err := row.Scan(
		&i.ID,
		&i.NotificationID,
		&i.EmailAddress,
		&i.Status,
		&i.SentAt,
		&i.DeliveredAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ProviderMessageID,
		&i.DeliveryMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmailDeliveryHistory = `-- name: GetEmailDeliveryHistory :many
SELECT 
    ed.id, ed.notification_id, ed.email_address, ed.status, ed.sent_at, ed.delivered_at, ed.failed_at, ed.error_message, ed.retry_count, ed.max_retries, ed.provider_message_id, ed.delivery_metadata, ed.created_at, ed.updated_at,
    n.title as notification_title,
    n.type as notification_type
FROM email_deliveries ed
JOIN notifications n ON ed.notification_id = n.id
WHERE ed.email_address = $1
ORDER BY ed.created_at DESC
LIMIT $2 OFFSET $3
`

type GetEmailDeliveryHistoryParams struct {
	EmailAddress string `db:"email_address" json:"email_address"`
	Limit        int32  `db:"limit" json:"limit"`
	Offset       int32  `db:"offset" json:"offset"`
}

type GetEmailDeliveryHistoryRow struct {
	ID                int32            `db:"id" json:"id"`
	NotificationID    int32            `db:"notification_id" json:"notification_id"`
	EmailAddress      string           `db:"email_address" json:"email_address"`
	Status            string           `db:"status" json:"status"`
	SentAt            pgtype.Timestamp `db:"sent_at" json:"sent_at"`
	DeliveredAt       pgtype.Timestamp `db:"delivered_at" json:"delivered_at"`
	FailedAt          pgtype.Timestamp `db:"failed_at" json:"failed_at"`
	ErrorMessage      pgtype.Text      `db:"error_message" json:"error_message"`
	RetryCount        pgtype.Int4      `db:"retry_count" json:"retry_count"`
	MaxRetries        pgtype.Int4      `db:"max_retries" json:"max_retries"`
	ProviderMessageID pgtype.Text      `db:"provider_message_id" json:"provider_message_id"`
	DeliveryMetadata  []byte           `db:"delivery_metadata" json:"delivery_metadata"`
	CreatedAt         pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	NotificationTitle string           `db:"notification_title" json:"notification_title"`
	NotificationType  string           `db:"notification_type" json:"notification_type"`
}

func (q *Queries) GetEmailDeliveryHistory(ctx context.Context, arg GetEmailDeliveryHistoryParams) ([]GetEmailDeliveryHistoryRow, error) {
	rows, err := q.db.Query(ctx, getEmailDeliveryHistory, arg.EmailAddress, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEmailDeliveryHistoryRow{}
	for rows.Next() {
		var i GetEmailDeliveryHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.NotificationID,
			&i.EmailAddress,
			&i.Status,
			&i.SentAt,
			&i.DeliveredAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.ProviderMessageID,
			&i.DeliveryMetadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NotificationTitle,
			&i.NotificationType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailDeliveryStats = `-- name: GetEmailDeliveryStats :one
SELECT 
    COUNT(*) as total,
    COUNT(*) FILTER (WHERE status = 'pending') as pending,
    COUNT(*) FILTER (WHERE status = 'sent') as sent,
    COUNT(*) FILTER (WHERE status = 'delivered') as delivered,
    COUNT(*) FILTER (WHERE status = 'failed') as failed,
    COUNT(*) FILTER (WHERE status = 'bounced') as bounced,
    COALESCE(AVG(EXTRACT(EPOCH FROM (delivered_at - sent_at))), 0) as avg_delivery_time_seconds
FROM email_deliveries
WHERE created_at >= $1 AND created_at <= $2
`

type GetEmailDeliveryStatsParams struct {
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	CreatedAt_2 pgtype.Timestamp `db:"created_at_2" json:"created_at_2"`
}

type GetEmailDeliveryStatsRow struct {
	Total                  int64       `db:"total" json:"total"`
	Pending                int64       `db:"pending" json:"pending"`
	Sent                   int64       `db:"sent" json:"sent"`
	Delivered              int64       `db:"delivered" json:"delivered"`
	Failed                 int64       `db:"failed" json:"failed"`
	Bounced                int64       `db:"bounced" json:"bounced"`
	AvgDeliveryTimeSeconds interface{} `db:"avg_delivery_time_seconds" json:"avg_delivery_time_seconds"`
}

func (q *Queries) GetEmailDeliveryStats(ctx context.Context, arg GetEmailDeliveryStatsParams) (GetEmailDeliveryStatsRow, error) {
	row := q.db.QueryRow(ctx, getEmailDeliveryStats, arg.CreatedAt, arg.CreatedAt_2)
	var i GetEmailDeliveryStatsRow
	err := row.Scan(
		&i.Total,
		&i.Pending,
		&i.Sent,
		&i.Delivered,
		&i.Failed,
		&i.Bounced,
		&i.AvgDeliveryTimeSeconds,
	)
	return i, err
}

const getFailedEmailDeliveries = `-- name: GetFailedEmailDeliveries :many
SELECT id, notification_id, email_address, status, sent_at, delivered_at, failed_at, error_message, retry_count, max_retries, provider_message_id, delivery_metadata, created_at, updated_at FROM email_deliveries 
WHERE status = 'failed' AND retry_count < max_retries
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetFailedEmailDeliveries(ctx context.Context, limit int32) ([]EmailDelivery, error) {
	rows, err := q.db.Query(ctx, getFailedEmailDeliveries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EmailDelivery{}
	for rows.Next() {
		var i EmailDelivery
		if err := rows.Scan(
			&i.ID,
			&i.NotificationID,
			&i.EmailAddress,
			&i.Status,
			&i.SentAt,
			&i.DeliveredAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.ProviderMessageID,
			&i.DeliveryMetadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingEmailDeliveries = `-- name: GetPendingEmailDeliveries :many
SELECT id, notification_id, email_address, status, sent_at, delivered_at, failed_at, error_message, retry_count, max_retries, provider_message_id, delivery_metadata, created_at, updated_at FROM email_deliveries 
WHERE status = 'pending' 
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetPendingEmailDeliveries(ctx context.Context, limit int32) ([]EmailDelivery, error) {
	rows, err := q.db.Query(ctx, getPendingEmailDeliveries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EmailDelivery{}
	for rows.Next() {
		var i EmailDelivery
		if err := rows.Scan(
			&i.ID,
			&i.NotificationID,
			&i.EmailAddress,
			&i.Status,
			&i.SentAt,
			&i.DeliveredAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.ProviderMessageID,
			&i.DeliveryMetadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmailDeliveryError = `-- name: UpdateEmailDeliveryError :one
UPDATE email_deliveries 
SET 
    status = 'failed',
    error_message = $2,
    retry_count = retry_count + 1,
    failed_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, notification_id, email_address, status, sent_at, delivered_at, failed_at, error_message, retry_count, max_retries, provider_message_id, delivery_metadata, created_at, updated_at
`

type UpdateEmailDeliveryErrorParams struct {
	ID           int32       `db:"id" json:"id"`
	ErrorMessage pgtype.Text `db:"error_message" json:"error_message"`
}

func (q *Queries) UpdateEmailDeliveryError(ctx context.Context, arg UpdateEmailDeliveryErrorParams) (EmailDelivery, error) {
	row := q.db.QueryRow(ctx, updateEmailDeliveryError, arg.ID, arg.ErrorMessage)
	var i EmailDelivery
	err := row.Scan(
		&i.ID,
		&i.NotificationID,
		&i.EmailAddress,
		&i.Status,
		&i.SentAt,
		&i.DeliveredAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ProviderMessageID,
		&i.DeliveryMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEmailDeliveryProviderInfo = `-- name: UpdateEmailDeliveryProviderInfo :one
UPDATE email_deliveries 
SET 
    provider_message_id = $2,
    delivery_metadata = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, notification_id, email_address, status, sent_at, delivered_at, failed_at, error_message, retry_count, max_retries, provider_message_id, delivery_metadata, created_at, updated_at
`

type UpdateEmailDeliveryProviderInfoParams struct {
	ID                int32       `db:"id" json:"id"`
	ProviderMessageID pgtype.Text `db:"provider_message_id" json:"provider_message_id"`
	DeliveryMetadata  []byte      `db:"delivery_metadata" json:"delivery_metadata"`
}

func (q *Queries) UpdateEmailDeliveryProviderInfo(ctx context.Context, arg UpdateEmailDeliveryProviderInfoParams) (EmailDelivery, error) {
	row := q.db.QueryRow(ctx, updateEmailDeliveryProviderInfo, arg.ID, arg.ProviderMessageID, arg.DeliveryMetadata)
	var i EmailDelivery
	err := row.Scan(
		&i.ID,
		&i.NotificationID,
		&i.EmailAddress,
		&i.Status,
		&i.SentAt,
		&i.DeliveredAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ProviderMessageID,
		&i.DeliveryMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEmailDeliveryStatus = `-- name: UpdateEmailDeliveryStatus :one
UPDATE email_deliveries 
SET 
    status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, notification_id, email_address, status, sent_at, delivered_at, failed_at, error_message, retry_count, max_retries, provider_message_id, delivery_metadata, created_at, updated_at
`

type UpdateEmailDeliveryStatusParams struct {
	ID     int32  `db:"id" json:"id"`
	Status string `db:"status" json:"status"`
}

func (q *Queries) UpdateEmailDeliveryStatus(ctx context.Context, arg UpdateEmailDeliveryStatusParams) (EmailDelivery, error) {
	row := q.db.QueryRow(ctx, updateEmailDeliveryStatus, arg.ID, arg.Status)
	var i EmailDelivery
	err := row.Scan(
		&i.ID,
		&i.NotificationID,
		&i.EmailAddress,
		&i.Status,
		&i.SentAt,
		&i.DeliveredAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ProviderMessageID,
		&i.DeliveryMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEmailDeliveryToDelivered = `-- name: UpdateEmailDeliveryToDelivered :one
UPDATE email_deliveries 
SET 
    status = 'delivered',
    delivered_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, notification_id, email_address, status, sent_at, delivered_at, failed_at, error_message, retry_count, max_retries, provider_message_id, delivery_metadata, created_at, updated_at
`

func (q *Queries) UpdateEmailDeliveryToDelivered(ctx context.Context, id int32) (EmailDelivery, error) {
	row := q.db.QueryRow(ctx, updateEmailDeliveryToDelivered, id)
	var i EmailDelivery
	err := row.Scan(
		&i.ID,
		&i.NotificationID,
		&i.EmailAddress,
		&i.Status,
		&i.SentAt,
		&i.DeliveredAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ProviderMessageID,
		&i.DeliveryMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEmailDeliveryToFailed = `-- name: UpdateEmailDeliveryToFailed :one
UPDATE email_deliveries 
SET 
    status = 'failed',
    failed_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, notification_id, email_address, status, sent_at, delivered_at, failed_at, error_message, retry_count, max_retries, provider_message_id, delivery_metadata, created_at, updated_at
`

func (q *Queries) UpdateEmailDeliveryToFailed(ctx context.Context, id int32) (EmailDelivery, error) {
	row := q.db.QueryRow(ctx, updateEmailDeliveryToFailed, id)
	var i EmailDelivery
	err := row.Scan(
		&i.ID,
		&i.NotificationID,
		&i.EmailAddress,
		&i.Status,
		&i.SentAt,
		&i.DeliveredAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ProviderMessageID,
		&i.DeliveryMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEmailDeliveryToSent = `-- name: UpdateEmailDeliveryToSent :one
UPDATE email_deliveries 
SET 
    status = 'sent',
    sent_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, notification_id, email_address, status, sent_at, delivered_at, failed_at, error_message, retry_count, max_retries, provider_message_id, delivery_metadata, created_at, updated_at
`

func (q *Queries) UpdateEmailDeliveryToSent(ctx context.Context, id int32) (EmailDelivery, error) {
	row := q.db.QueryRow(ctx, updateEmailDeliveryToSent, id)
	var i EmailDelivery
	err := row.Scan(
		&i.ID,
		&i.NotificationID,
		&i.EmailAddress,
		&i.Status,
		&i.SentAt,
		&i.DeliveredAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ProviderMessageID,
		&i.DeliveryMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
